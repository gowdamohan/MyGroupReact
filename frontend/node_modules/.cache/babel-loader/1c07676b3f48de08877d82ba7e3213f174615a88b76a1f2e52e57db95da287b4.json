{"ast":null,"code":"import _objectSpread from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectDestructuringEmpty from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/objectDestructuringEmpty.js\";\nimport _classPrivateMethodInitSpec from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _assertClassBrand from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldGet from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nvar _client, _currentQuery, _currentQueryInitialState, _currentResult, _currentResultState, _currentResultOptions, _currentThenable, _selectError, _selectFn, _selectResult, _lastQueryWithDefinedData, _staleTimeoutId, _refetchIntervalId, _currentRefetchInterval, _trackedProps, _Class_brand;\n// src/queryObserver.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { fetchState } from \"./query.js\";\nimport { Subscribable } from \"./subscribable.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport { isServer, isValidTimeout, noop, replaceData, resolveEnabled, resolveStaleTime, shallowEqualObjects, timeUntilStale } from \"./utils.js\";\nvar QueryObserver = (_client = /*#__PURE__*/new WeakMap(), _currentQuery = /*#__PURE__*/new WeakMap(), _currentQueryInitialState = /*#__PURE__*/new WeakMap(), _currentResult = /*#__PURE__*/new WeakMap(), _currentResultState = /*#__PURE__*/new WeakMap(), _currentResultOptions = /*#__PURE__*/new WeakMap(), _currentThenable = /*#__PURE__*/new WeakMap(), _selectError = /*#__PURE__*/new WeakMap(), _selectFn = /*#__PURE__*/new WeakMap(), _selectResult = /*#__PURE__*/new WeakMap(), _lastQueryWithDefinedData = /*#__PURE__*/new WeakMap(), _staleTimeoutId = /*#__PURE__*/new WeakMap(), _refetchIntervalId = /*#__PURE__*/new WeakMap(), _currentRefetchInterval = /*#__PURE__*/new WeakMap(), _trackedProps = /*#__PURE__*/new WeakMap(), _Class_brand = /*#__PURE__*/new WeakSet(), class QueryObserver extends Subscribable {\n  constructor(client, options) {\n    super();\n    _classPrivateMethodInitSpec(this, _Class_brand);\n    _classPrivateFieldInitSpec(this, _client, void 0);\n    _classPrivateFieldInitSpec(this, _currentQuery, void 0);\n    _classPrivateFieldInitSpec(this, _currentQueryInitialState, void 0);\n    _classPrivateFieldInitSpec(this, _currentResult, void 0);\n    _classPrivateFieldInitSpec(this, _currentResultState, void 0);\n    _classPrivateFieldInitSpec(this, _currentResultOptions, void 0);\n    _classPrivateFieldInitSpec(this, _currentThenable, void 0);\n    _classPrivateFieldInitSpec(this, _selectError, void 0);\n    _classPrivateFieldInitSpec(this, _selectFn, void 0);\n    _classPrivateFieldInitSpec(this, _selectResult, void 0);\n    // This property keeps track of the last query with defined data.\n    // It will be used to pass the previous data and query to the placeholder function between renders.\n    _classPrivateFieldInitSpec(this, _lastQueryWithDefinedData, void 0);\n    _classPrivateFieldInitSpec(this, _staleTimeoutId, void 0);\n    _classPrivateFieldInitSpec(this, _refetchIntervalId, void 0);\n    _classPrivateFieldInitSpec(this, _currentRefetchInterval, void 0);\n    _classPrivateFieldInitSpec(this, _trackedProps, /* @__PURE__ */new Set());\n    this.options = options;\n    _classPrivateFieldSet(_client, this, client);\n    _classPrivateFieldSet(_selectError, this, null);\n    _classPrivateFieldSet(_currentThenable, this, pendingThenable());\n    if (!this.options.experimental_prefetchInRender) {\n      _classPrivateFieldGet(_currentThenable, this).reject(new Error(\"experimental_prefetchInRender feature flag is not enabled\"));\n    }\n    this.bindMethods();\n    this.setOptions(options);\n  }\n  bindMethods() {\n    this.refetch = this.refetch.bind(this);\n  }\n  onSubscribe() {\n    if (this.listeners.size === 1) {\n      _classPrivateFieldGet(_currentQuery, this).addObserver(this);\n      if (shouldFetchOnMount(_classPrivateFieldGet(_currentQuery, this), this.options)) {\n        _assertClassBrand(_Class_brand, this, _executeFetch).call(this);\n      } else {\n        this.updateResult();\n      }\n      _assertClassBrand(_Class_brand, this, _updateTimers).call(this);\n    }\n  }\n  onUnsubscribe() {\n    if (!this.hasListeners()) {\n      this.destroy();\n    }\n  }\n  shouldFetchOnReconnect() {\n    return shouldFetchOn(_classPrivateFieldGet(_currentQuery, this), this.options, this.options.refetchOnReconnect);\n  }\n  shouldFetchOnWindowFocus() {\n    return shouldFetchOn(_classPrivateFieldGet(_currentQuery, this), this.options, this.options.refetchOnWindowFocus);\n  }\n  destroy() {\n    this.listeners = /* @__PURE__ */new Set();\n    _assertClassBrand(_Class_brand, this, _clearStaleTimeout).call(this);\n    _assertClassBrand(_Class_brand, this, _clearRefetchInterval).call(this);\n    _classPrivateFieldGet(_currentQuery, this).removeObserver(this);\n  }\n  setOptions(options) {\n    const prevOptions = this.options;\n    const prevQuery = _classPrivateFieldGet(_currentQuery, this);\n    this.options = _classPrivateFieldGet(_client, this).defaultQueryOptions(options);\n    if (this.options.enabled !== void 0 && typeof this.options.enabled !== \"boolean\" && typeof this.options.enabled !== \"function\" && typeof resolveEnabled(this.options.enabled, _classPrivateFieldGet(_currentQuery, this)) !== \"boolean\") {\n      throw new Error(\"Expected enabled to be a boolean or a callback that returns a boolean\");\n    }\n    _assertClassBrand(_Class_brand, this, _updateQuery).call(this);\n    _classPrivateFieldGet(_currentQuery, this).setOptions(this.options);\n    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {\n      _classPrivateFieldGet(_client, this).getQueryCache().notify({\n        type: \"observerOptionsUpdated\",\n        query: _classPrivateFieldGet(_currentQuery, this),\n        observer: this\n      });\n    }\n    const mounted = this.hasListeners();\n    if (mounted && shouldFetchOptionally(_classPrivateFieldGet(_currentQuery, this), prevQuery, this.options, prevOptions)) {\n      _assertClassBrand(_Class_brand, this, _executeFetch).call(this);\n    }\n    this.updateResult();\n    if (mounted && (_classPrivateFieldGet(_currentQuery, this) !== prevQuery || resolveEnabled(this.options.enabled, _classPrivateFieldGet(_currentQuery, this)) !== resolveEnabled(prevOptions.enabled, _classPrivateFieldGet(_currentQuery, this)) || resolveStaleTime(this.options.staleTime, _classPrivateFieldGet(_currentQuery, this)) !== resolveStaleTime(prevOptions.staleTime, _classPrivateFieldGet(_currentQuery, this)))) {\n      _assertClassBrand(_Class_brand, this, _updateStaleTimeout).call(this);\n    }\n    const nextRefetchInterval = _assertClassBrand(_Class_brand, this, _computeRefetchInterval).call(this);\n    if (mounted && (_classPrivateFieldGet(_currentQuery, this) !== prevQuery || resolveEnabled(this.options.enabled, _classPrivateFieldGet(_currentQuery, this)) !== resolveEnabled(prevOptions.enabled, _classPrivateFieldGet(_currentQuery, this)) || nextRefetchInterval !== _classPrivateFieldGet(_currentRefetchInterval, this))) {\n      _assertClassBrand(_Class_brand, this, _updateRefetchInterval).call(this, nextRefetchInterval);\n    }\n  }\n  getOptimisticResult(options) {\n    const query = _classPrivateFieldGet(_client, this).getQueryCache().build(_classPrivateFieldGet(_client, this), options);\n    const result = this.createResult(query, options);\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      _classPrivateFieldSet(_currentResult, this, result);\n      _classPrivateFieldSet(_currentResultOptions, this, this.options);\n      _classPrivateFieldSet(_currentResultState, this, _classPrivateFieldGet(_currentQuery, this).state);\n    }\n    return result;\n  }\n  getCurrentResult() {\n    return _classPrivateFieldGet(_currentResult, this);\n  }\n  trackResult(result, onPropTracked) {\n    return new Proxy(result, {\n      get: (target, key) => {\n        this.trackProp(key);\n        onPropTracked === null || onPropTracked === void 0 || onPropTracked(key);\n        return Reflect.get(target, key);\n      }\n    });\n  }\n  trackProp(key) {\n    _classPrivateFieldGet(_trackedProps, this).add(key);\n  }\n  getCurrentQuery() {\n    return _classPrivateFieldGet(_currentQuery, this);\n  }\n  refetch() {\n    let _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      options = Object.assign({}, (_objectDestructuringEmpty(_ref), _ref));\n    return this.fetch(_objectSpread({}, options));\n  }\n  fetchOptimistic(options) {\n    const defaultedOptions = _classPrivateFieldGet(_client, this).defaultQueryOptions(options);\n    const query = _classPrivateFieldGet(_client, this).getQueryCache().build(_classPrivateFieldGet(_client, this), defaultedOptions);\n    return query.fetch().then(() => this.createResult(query, defaultedOptions));\n  }\n  fetch(fetchOptions) {\n    var _fetchOptions$cancelR;\n    return _assertClassBrand(_Class_brand, this, _executeFetch).call(this, _objectSpread(_objectSpread({}, fetchOptions), {}, {\n      cancelRefetch: (_fetchOptions$cancelR = fetchOptions.cancelRefetch) !== null && _fetchOptions$cancelR !== void 0 ? _fetchOptions$cancelR : true\n    })).then(() => {\n      this.updateResult();\n      return _classPrivateFieldGet(_currentResult, this);\n    });\n  }\n  createResult(query, options) {\n    const prevQuery = _classPrivateFieldGet(_currentQuery, this);\n    const prevOptions = this.options;\n    const prevResult = _classPrivateFieldGet(_currentResult, this);\n    const prevResultState = _classPrivateFieldGet(_currentResultState, this);\n    const prevResultOptions = _classPrivateFieldGet(_currentResultOptions, this);\n    const queryChange = query !== prevQuery;\n    const queryInitialState = queryChange ? query.state : _classPrivateFieldGet(_currentQueryInitialState, this);\n    const {\n      state\n    } = query;\n    let newState = _objectSpread({}, state);\n    let isPlaceholderData = false;\n    let data;\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners();\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);\n      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);\n      if (fetchOnMount || fetchOptionally) {\n        newState = _objectSpread(_objectSpread({}, newState), fetchState(state.data, query.options));\n      }\n      if (options._optimisticResults === \"isRestoring\") {\n        newState.fetchStatus = \"idle\";\n      }\n    }\n    let {\n      error,\n      errorUpdatedAt,\n      status\n    } = newState;\n    data = newState.data;\n    let skipSelect = false;\n    if (options.placeholderData !== void 0 && data === void 0 && status === \"pending\") {\n      let placeholderData;\n      if (prevResult !== null && prevResult !== void 0 && prevResult.isPlaceholderData && options.placeholderData === (prevResultOptions === null || prevResultOptions === void 0 ? void 0 : prevResultOptions.placeholderData)) {\n        placeholderData = prevResult.data;\n        skipSelect = true;\n      } else {\n        var _classPrivateFieldGet2;\n        placeholderData = typeof options.placeholderData === \"function\" ? options.placeholderData((_classPrivateFieldGet2 = _classPrivateFieldGet(_lastQueryWithDefinedData, this)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.state.data, _classPrivateFieldGet(_lastQueryWithDefinedData, this)) : options.placeholderData;\n      }\n      if (placeholderData !== void 0) {\n        status = \"success\";\n        data = replaceData(prevResult === null || prevResult === void 0 ? void 0 : prevResult.data, placeholderData, options);\n        isPlaceholderData = true;\n      }\n    }\n    if (options.select && data !== void 0 && !skipSelect) {\n      if (prevResult && data === (prevResultState === null || prevResultState === void 0 ? void 0 : prevResultState.data) && options.select === _classPrivateFieldGet(_selectFn, this)) {\n        data = _classPrivateFieldGet(_selectResult, this);\n      } else {\n        try {\n          _classPrivateFieldSet(_selectFn, this, options.select);\n          data = options.select(data);\n          data = replaceData(prevResult === null || prevResult === void 0 ? void 0 : prevResult.data, data, options);\n          _classPrivateFieldSet(_selectResult, this, data);\n          _classPrivateFieldSet(_selectError, this, null);\n        } catch (selectError) {\n          _classPrivateFieldSet(_selectError, this, selectError);\n        }\n      }\n    }\n    if (_classPrivateFieldGet(_selectError, this)) {\n      error = _classPrivateFieldGet(_selectError, this);\n      data = _classPrivateFieldGet(_selectResult, this);\n      errorUpdatedAt = Date.now();\n      status = \"error\";\n    }\n    const isFetching = newState.fetchStatus === \"fetching\";\n    const isPending = status === \"pending\";\n    const isError = status === \"error\";\n    const isLoading = isPending && isFetching;\n    const hasData = data !== void 0;\n    const result = {\n      status,\n      fetchStatus: newState.fetchStatus,\n      isPending,\n      isSuccess: status === \"success\",\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: newState.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: newState.fetchFailureCount,\n      failureReason: newState.fetchFailureReason,\n      errorUpdateCount: newState.errorUpdateCount,\n      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,\n      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && !hasData,\n      isPaused: newState.fetchStatus === \"paused\",\n      isPlaceholderData,\n      isRefetchError: isError && hasData,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n      promise: _classPrivateFieldGet(_currentThenable, this),\n      isEnabled: resolveEnabled(options.enabled, query) !== false\n    };\n    const nextResult = result;\n    if (this.options.experimental_prefetchInRender) {\n      const finalizeThenableIfPossible = thenable => {\n        if (nextResult.status === \"error\") {\n          thenable.reject(nextResult.error);\n        } else if (nextResult.data !== void 0) {\n          thenable.resolve(nextResult.data);\n        }\n      };\n      const recreateThenable = () => {\n        const pending = _classPrivateFieldSet(_currentThenable, this, nextResult.promise = pendingThenable());\n        finalizeThenableIfPossible(pending);\n      };\n      const prevThenable = _classPrivateFieldGet(_currentThenable, this);\n      switch (prevThenable.status) {\n        case \"pending\":\n          if (query.queryHash === prevQuery.queryHash) {\n            finalizeThenableIfPossible(prevThenable);\n          }\n          break;\n        case \"fulfilled\":\n          if (nextResult.status === \"error\" || nextResult.data !== prevThenable.value) {\n            recreateThenable();\n          }\n          break;\n        case \"rejected\":\n          if (nextResult.status !== \"error\" || nextResult.error !== prevThenable.reason) {\n            recreateThenable();\n          }\n          break;\n      }\n    }\n    return nextResult;\n  }\n  updateResult() {\n    const prevResult = _classPrivateFieldGet(_currentResult, this);\n    const nextResult = this.createResult(_classPrivateFieldGet(_currentQuery, this), this.options);\n    _classPrivateFieldSet(_currentResultState, this, _classPrivateFieldGet(_currentQuery, this).state);\n    _classPrivateFieldSet(_currentResultOptions, this, this.options);\n    if (_classPrivateFieldGet(_currentResultState, this).data !== void 0) {\n      _classPrivateFieldSet(_lastQueryWithDefinedData, this, _classPrivateFieldGet(_currentQuery, this));\n    }\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return;\n    }\n    _classPrivateFieldSet(_currentResult, this, nextResult);\n    const shouldNotifyListeners = () => {\n      if (!prevResult) {\n        return true;\n      }\n      const {\n        notifyOnChangeProps\n      } = this.options;\n      const notifyOnChangePropsValue = typeof notifyOnChangeProps === \"function\" ? notifyOnChangeProps() : notifyOnChangeProps;\n      if (notifyOnChangePropsValue === \"all\" || !notifyOnChangePropsValue && !_classPrivateFieldGet(_trackedProps, this).size) {\n        return true;\n      }\n      const includedProps = new Set(notifyOnChangePropsValue !== null && notifyOnChangePropsValue !== void 0 ? notifyOnChangePropsValue : _classPrivateFieldGet(_trackedProps, this));\n      if (this.options.throwOnError) {\n        includedProps.add(\"error\");\n      }\n      return Object.keys(_classPrivateFieldGet(_currentResult, this)).some(key => {\n        const typedKey = key;\n        const changed = _classPrivateFieldGet(_currentResult, this)[typedKey] !== prevResult[typedKey];\n        return changed && includedProps.has(typedKey);\n      });\n    };\n    _assertClassBrand(_Class_brand, this, _notify).call(this, {\n      listeners: shouldNotifyListeners()\n    });\n  }\n  onQueryUpdate() {\n    this.updateResult();\n    if (this.hasListeners()) {\n      _assertClassBrand(_Class_brand, this, _updateTimers).call(this);\n    }\n  }\n});\nfunction _executeFetch(fetchOptions) {\n  _assertClassBrand(_Class_brand, this, _updateQuery).call(this);\n  let promise = _classPrivateFieldGet(_currentQuery, this).fetch(this.options, fetchOptions);\n  if (!(fetchOptions !== null && fetchOptions !== void 0 && fetchOptions.throwOnError)) {\n    promise = promise.catch(noop);\n  }\n  return promise;\n}\nfunction _updateStaleTimeout() {\n  _assertClassBrand(_Class_brand, this, _clearStaleTimeout).call(this);\n  const staleTime = resolveStaleTime(this.options.staleTime, _classPrivateFieldGet(_currentQuery, this));\n  if (isServer || _classPrivateFieldGet(_currentResult, this).isStale || !isValidTimeout(staleTime)) {\n    return;\n  }\n  const time = timeUntilStale(_classPrivateFieldGet(_currentResult, this).dataUpdatedAt, staleTime);\n  const timeout = time + 1;\n  _classPrivateFieldSet(_staleTimeoutId, this, setTimeout(() => {\n    if (!_classPrivateFieldGet(_currentResult, this).isStale) {\n      this.updateResult();\n    }\n  }, timeout));\n}\nfunction _computeRefetchInterval() {\n  var _ref2;\n  return (_ref2 = typeof this.options.refetchInterval === \"function\" ? this.options.refetchInterval(_classPrivateFieldGet(_currentQuery, this)) : this.options.refetchInterval) !== null && _ref2 !== void 0 ? _ref2 : false;\n}\nfunction _updateRefetchInterval(nextInterval) {\n  _assertClassBrand(_Class_brand, this, _clearRefetchInterval).call(this);\n  _classPrivateFieldSet(_currentRefetchInterval, this, nextInterval);\n  if (isServer || resolveEnabled(this.options.enabled, _classPrivateFieldGet(_currentQuery, this)) === false || !isValidTimeout(_classPrivateFieldGet(_currentRefetchInterval, this)) || _classPrivateFieldGet(_currentRefetchInterval, this) === 0) {\n    return;\n  }\n  _classPrivateFieldSet(_refetchIntervalId, this, setInterval(() => {\n    if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {\n      _assertClassBrand(_Class_brand, this, _executeFetch).call(this);\n    }\n  }, _classPrivateFieldGet(_currentRefetchInterval, this)));\n}\nfunction _updateTimers() {\n  _assertClassBrand(_Class_brand, this, _updateStaleTimeout).call(this);\n  _assertClassBrand(_Class_brand, this, _updateRefetchInterval).call(this, _assertClassBrand(_Class_brand, this, _computeRefetchInterval).call(this));\n}\nfunction _clearStaleTimeout() {\n  if (_classPrivateFieldGet(_staleTimeoutId, this)) {\n    clearTimeout(_classPrivateFieldGet(_staleTimeoutId, this));\n    _classPrivateFieldSet(_staleTimeoutId, this, void 0);\n  }\n}\nfunction _clearRefetchInterval() {\n  if (_classPrivateFieldGet(_refetchIntervalId, this)) {\n    clearInterval(_classPrivateFieldGet(_refetchIntervalId, this));\n    _classPrivateFieldSet(_refetchIntervalId, this, void 0);\n  }\n}\nfunction _updateQuery() {\n  const query = _classPrivateFieldGet(_client, this).getQueryCache().build(_classPrivateFieldGet(_client, this), this.options);\n  if (query === _classPrivateFieldGet(_currentQuery, this)) {\n    return;\n  }\n  const prevQuery = _classPrivateFieldGet(_currentQuery, this);\n  _classPrivateFieldSet(_currentQuery, this, query);\n  _classPrivateFieldSet(_currentQueryInitialState, this, query.state);\n  if (this.hasListeners()) {\n    prevQuery === null || prevQuery === void 0 || prevQuery.removeObserver(this);\n    query.addObserver(this);\n  }\n}\nfunction _notify(notifyOptions) {\n  notifyManager.batch(() => {\n    if (notifyOptions.listeners) {\n      this.listeners.forEach(listener => {\n        listener(_classPrivateFieldGet(_currentResult, this));\n      });\n    }\n    _classPrivateFieldGet(_client, this).getQueryCache().notify({\n      query: _classPrivateFieldGet(_currentQuery, this),\n      type: \"observerResultsUpdated\"\n    });\n  });\n}\nfunction shouldLoadOnMount(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === \"error\" && options.retryOnMount === false);\n}\nfunction shouldFetchOnMount(query, options) {\n  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);\n}\nfunction shouldFetchOn(query, options, field) {\n  if (resolveEnabled(options.enabled, query) !== false && resolveStaleTime(options.staleTime, query) !== \"static\") {\n    const value = typeof field === \"function\" ? field(query) : field;\n    return value === \"always\" || value !== false && isStale(query, options);\n  }\n  return false;\n}\nfunction shouldFetchOptionally(query, prevQuery, options, prevOptions) {\n  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== \"error\") && isStale(query, options);\n}\nfunction isStale(query, options) {\n  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));\n}\nfunction shouldAssignObserverCurrentProperties(observer, optimisticResult) {\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true;\n  }\n  return false;\n}\nexport { QueryObserver };\n//# sourceMappingURL=queryObserver.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}