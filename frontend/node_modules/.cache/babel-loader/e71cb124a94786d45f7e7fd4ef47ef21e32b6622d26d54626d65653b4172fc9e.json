{"ast":null,"code":"import _objectWithoutProperties from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nconst _excluded = [\"state\"],\n  _excluded2 = [\"fetchStatus\"];\n// src/hydration.ts\nimport { tryResolveSync } from \"./thenable.js\";\nfunction defaultTransformerFn(data) {\n  return data;\n}\nfunction dehydrateMutation(mutation) {\n  return _objectSpread(_objectSpread({\n    mutationKey: mutation.options.mutationKey,\n    state: mutation.state\n  }, mutation.options.scope && {\n    scope: mutation.options.scope\n  }), mutation.meta && {\n    meta: mutation.meta\n  });\n}\nfunction dehydrateQuery(query, serializeData, shouldRedactErrors) {\n  var _query$promise;\n  return _objectSpread(_objectSpread({\n    dehydratedAt: Date.now(),\n    state: _objectSpread(_objectSpread({}, query.state), query.state.data !== void 0 && {\n      data: serializeData(query.state.data)\n    }),\n    queryKey: query.queryKey,\n    queryHash: query.queryHash\n  }, query.state.status === \"pending\" && {\n    promise: (_query$promise = query.promise) === null || _query$promise === void 0 ? void 0 : _query$promise.then(serializeData).catch(error => {\n      if (!shouldRedactErrors(error)) {\n        return Promise.reject(error);\n      }\n      if (process.env.NODE_ENV !== \"production\") {\n        console.error(\"A query that was dehydrated as pending ended up rejecting. [\".concat(query.queryHash, \"]: \").concat(error, \"; The error will be redacted in production builds\"));\n      }\n      return Promise.reject(new Error(\"redacted\"));\n    })\n  }), query.meta && {\n    meta: query.meta\n  });\n}\nfunction defaultShouldDehydrateMutation(mutation) {\n  return mutation.state.isPaused;\n}\nfunction defaultShouldDehydrateQuery(query) {\n  return query.state.status === \"success\";\n}\nfunction defaultShouldRedactErrors(_) {\n  return true;\n}\nfunction dehydrate(client) {\n  var _ref, _options$shouldDehydr, _client$getDefaultOpt, _ref2, _options$shouldDehydr2, _client$getDefaultOpt2, _ref3, _options$shouldRedact, _client$getDefaultOpt3, _ref4, _options$serializeDat, _client$getDefaultOpt4;\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const filterMutation = (_ref = (_options$shouldDehydr = options.shouldDehydrateMutation) !== null && _options$shouldDehydr !== void 0 ? _options$shouldDehydr : (_client$getDefaultOpt = client.getDefaultOptions().dehydrate) === null || _client$getDefaultOpt === void 0 ? void 0 : _client$getDefaultOpt.shouldDehydrateMutation) !== null && _ref !== void 0 ? _ref : defaultShouldDehydrateMutation;\n  const mutations = client.getMutationCache().getAll().flatMap(mutation => filterMutation(mutation) ? [dehydrateMutation(mutation)] : []);\n  const filterQuery = (_ref2 = (_options$shouldDehydr2 = options.shouldDehydrateQuery) !== null && _options$shouldDehydr2 !== void 0 ? _options$shouldDehydr2 : (_client$getDefaultOpt2 = client.getDefaultOptions().dehydrate) === null || _client$getDefaultOpt2 === void 0 ? void 0 : _client$getDefaultOpt2.shouldDehydrateQuery) !== null && _ref2 !== void 0 ? _ref2 : defaultShouldDehydrateQuery;\n  const shouldRedactErrors = (_ref3 = (_options$shouldRedact = options.shouldRedactErrors) !== null && _options$shouldRedact !== void 0 ? _options$shouldRedact : (_client$getDefaultOpt3 = client.getDefaultOptions().dehydrate) === null || _client$getDefaultOpt3 === void 0 ? void 0 : _client$getDefaultOpt3.shouldRedactErrors) !== null && _ref3 !== void 0 ? _ref3 : defaultShouldRedactErrors;\n  const serializeData = (_ref4 = (_options$serializeDat = options.serializeData) !== null && _options$serializeDat !== void 0 ? _options$serializeDat : (_client$getDefaultOpt4 = client.getDefaultOptions().dehydrate) === null || _client$getDefaultOpt4 === void 0 ? void 0 : _client$getDefaultOpt4.serializeData) !== null && _ref4 !== void 0 ? _ref4 : defaultTransformerFn;\n  const queries = client.getQueryCache().getAll().flatMap(query => filterQuery(query) ? [dehydrateQuery(query, serializeData, shouldRedactErrors)] : []);\n  return {\n    mutations,\n    queries\n  };\n}\nfunction hydrate(client, dehydratedState, options) {\n  var _ref5, _options$defaultOptio, _options$defaultOptio2, _client$getDefaultOpt5;\n  if (typeof dehydratedState !== \"object\" || dehydratedState === null) {\n    return;\n  }\n  const mutationCache = client.getMutationCache();\n  const queryCache = client.getQueryCache();\n  const deserializeData = (_ref5 = (_options$defaultOptio = options === null || options === void 0 || (_options$defaultOptio2 = options.defaultOptions) === null || _options$defaultOptio2 === void 0 ? void 0 : _options$defaultOptio2.deserializeData) !== null && _options$defaultOptio !== void 0 ? _options$defaultOptio : (_client$getDefaultOpt5 = client.getDefaultOptions().hydrate) === null || _client$getDefaultOpt5 === void 0 ? void 0 : _client$getDefaultOpt5.deserializeData) !== null && _ref5 !== void 0 ? _ref5 : defaultTransformerFn;\n  const mutations = dehydratedState.mutations || [];\n  const queries = dehydratedState.queries || [];\n  mutations.forEach(_ref6 => {\n    var _client$getDefaultOpt6, _options$defaultOptio3;\n    let {\n        state\n      } = _ref6,\n      mutationOptions = _objectWithoutProperties(_ref6, _excluded);\n    mutationCache.build(client, _objectSpread(_objectSpread(_objectSpread({}, (_client$getDefaultOpt6 = client.getDefaultOptions().hydrate) === null || _client$getDefaultOpt6 === void 0 ? void 0 : _client$getDefaultOpt6.mutations), options === null || options === void 0 || (_options$defaultOptio3 = options.defaultOptions) === null || _options$defaultOptio3 === void 0 ? void 0 : _options$defaultOptio3.mutations), mutationOptions), state);\n  });\n  queries.forEach(_ref7 => {\n    var _query, _query2;\n    let {\n      queryKey,\n      state,\n      queryHash,\n      meta,\n      promise,\n      dehydratedAt\n    } = _ref7;\n    const syncData = promise ? tryResolveSync(promise) : void 0;\n    const rawData = state.data === void 0 ? syncData === null || syncData === void 0 ? void 0 : syncData.data : state.data;\n    const data = rawData === void 0 ? rawData : deserializeData(rawData);\n    let query = queryCache.get(queryHash);\n    const existingQueryIsPending = ((_query = query) === null || _query === void 0 ? void 0 : _query.state.status) === \"pending\";\n    const existingQueryIsFetching = ((_query2 = query) === null || _query2 === void 0 ? void 0 : _query2.state.fetchStatus) === \"fetching\";\n    if (query) {\n      const hasNewerSyncData = syncData &&\n      // We only need this undefined check to handle older dehydration\n      // payloads that might not have dehydratedAt\n      dehydratedAt !== void 0 && dehydratedAt > query.state.dataUpdatedAt;\n      if (state.dataUpdatedAt > query.state.dataUpdatedAt || hasNewerSyncData) {\n        const {\n            fetchStatus: _ignored\n          } = state,\n          serializedState = _objectWithoutProperties(state, _excluded2);\n        query.setState(_objectSpread(_objectSpread({}, serializedState), {}, {\n          data\n        }));\n      }\n    } else {\n      var _client$getDefaultOpt7, _options$defaultOptio4;\n      query = queryCache.build(client, _objectSpread(_objectSpread(_objectSpread({}, (_client$getDefaultOpt7 = client.getDefaultOptions().hydrate) === null || _client$getDefaultOpt7 === void 0 ? void 0 : _client$getDefaultOpt7.queries), options === null || options === void 0 || (_options$defaultOptio4 = options.defaultOptions) === null || _options$defaultOptio4 === void 0 ? void 0 : _options$defaultOptio4.queries), {}, {\n        queryKey,\n        queryHash,\n        meta\n      }), // Reset fetch status to idle to avoid\n      // query being stuck in fetching state upon hydration\n      _objectSpread(_objectSpread({}, state), {}, {\n        data,\n        fetchStatus: \"idle\",\n        status: data !== void 0 ? \"success\" : state.status\n      }));\n    }\n    if (promise && !existingQueryIsPending && !existingQueryIsFetching && (\n    // Only hydrate if dehydration is newer than any existing data,\n    // this is always true for new queries\n    dehydratedAt === void 0 || dehydratedAt > query.state.dataUpdatedAt)) {\n      void query.fetch(void 0, {\n        // RSC transformed promises are not thenable\n        initialPromise: Promise.resolve(promise).then(deserializeData)\n      });\n    }\n  });\n}\nexport { defaultShouldDehydrateMutation, defaultShouldDehydrateQuery, dehydrate, hydrate };\n//# sourceMappingURL=hydration.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}