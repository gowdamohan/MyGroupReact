{"ast":null,"code":"import _objectSpread from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classPrivateMethodInitSpec from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateMethodInitSpec.js\";\nimport _classPrivateFieldInitSpec from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _assertClassBrand from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/assertClassBrand.js\";\nimport _classPrivateFieldGet from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nvar _initialState, _revertState, _cache, _client, _retryer, _defaultOptions, _abortSignalConsumed, _Class_brand;\n// src/query.ts\nimport { ensureQueryFn, noop, replaceData, resolveEnabled, resolveStaleTime, skipToken, timeUntilStale } from \"./utils.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { canFetch, createRetryer, isCancelledError } from \"./retryer.js\";\nimport { Removable } from \"./removable.js\";\nvar Query = (_initialState = /*#__PURE__*/new WeakMap(), _revertState = /*#__PURE__*/new WeakMap(), _cache = /*#__PURE__*/new WeakMap(), _client = /*#__PURE__*/new WeakMap(), _retryer = /*#__PURE__*/new WeakMap(), _defaultOptions = /*#__PURE__*/new WeakMap(), _abortSignalConsumed = /*#__PURE__*/new WeakMap(), _Class_brand = /*#__PURE__*/new WeakSet(), class Query extends Removable {\n  constructor(config) {\n    var _config$state;\n    super();\n    _classPrivateMethodInitSpec(this, _Class_brand);\n    _classPrivateFieldInitSpec(this, _initialState, void 0);\n    _classPrivateFieldInitSpec(this, _revertState, void 0);\n    _classPrivateFieldInitSpec(this, _cache, void 0);\n    _classPrivateFieldInitSpec(this, _client, void 0);\n    _classPrivateFieldInitSpec(this, _retryer, void 0);\n    _classPrivateFieldInitSpec(this, _defaultOptions, void 0);\n    _classPrivateFieldInitSpec(this, _abortSignalConsumed, void 0);\n    _classPrivateFieldSet(_abortSignalConsumed, this, false);\n    _classPrivateFieldSet(_defaultOptions, this, config.defaultOptions);\n    this.setOptions(config.options);\n    this.observers = [];\n    _classPrivateFieldSet(_client, this, config.client);\n    _classPrivateFieldSet(_cache, this, _classPrivateFieldGet(_client, this).getQueryCache());\n    this.queryKey = config.queryKey;\n    this.queryHash = config.queryHash;\n    _classPrivateFieldSet(_initialState, this, getDefaultState(this.options));\n    this.state = (_config$state = config.state) !== null && _config$state !== void 0 ? _config$state : _classPrivateFieldGet(_initialState, this);\n    this.scheduleGc();\n  }\n  get meta() {\n    return this.options.meta;\n  }\n  get promise() {\n    var _classPrivateFieldGet2;\n    return (_classPrivateFieldGet2 = _classPrivateFieldGet(_retryer, this)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.promise;\n  }\n  setOptions(options) {\n    this.options = _objectSpread(_objectSpread({}, _classPrivateFieldGet(_defaultOptions, this)), options);\n    this.updateGcTime(this.options.gcTime);\n  }\n  optionalRemove() {\n    if (!this.observers.length && this.state.fetchStatus === \"idle\") {\n      _classPrivateFieldGet(_cache, this).remove(this);\n    }\n  }\n  setData(newData, options) {\n    const data = replaceData(this.state.data, newData, this.options);\n    _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n      data,\n      type: \"success\",\n      dataUpdatedAt: options === null || options === void 0 ? void 0 : options.updatedAt,\n      manual: options === null || options === void 0 ? void 0 : options.manual\n    });\n    return data;\n  }\n  setState(state, setStateOptions) {\n    _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n      type: \"setState\",\n      state,\n      setStateOptions\n    });\n  }\n  cancel(options) {\n    var _classPrivateFieldGet3, _classPrivateFieldGet4;\n    const promise = (_classPrivateFieldGet3 = _classPrivateFieldGet(_retryer, this)) === null || _classPrivateFieldGet3 === void 0 ? void 0 : _classPrivateFieldGet3.promise;\n    (_classPrivateFieldGet4 = _classPrivateFieldGet(_retryer, this)) === null || _classPrivateFieldGet4 === void 0 || _classPrivateFieldGet4.cancel(options);\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve();\n  }\n  destroy() {\n    super.destroy();\n    this.cancel({\n      silent: true\n    });\n  }\n  reset() {\n    this.destroy();\n    this.setState(_classPrivateFieldGet(_initialState, this));\n  }\n  isActive() {\n    return this.observers.some(observer => resolveEnabled(observer.options.enabled, this) !== false);\n  }\n  isDisabled() {\n    if (this.getObserversCount() > 0) {\n      return !this.isActive();\n    }\n    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;\n  }\n  isStatic() {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(observer => resolveStaleTime(observer.options.staleTime, this) === \"static\");\n    }\n    return false;\n  }\n  isStale() {\n    if (this.getObserversCount() > 0) {\n      return this.observers.some(observer => observer.getCurrentResult().isStale);\n    }\n    return this.state.data === void 0 || this.state.isInvalidated;\n  }\n  isStaleByTime() {\n    let staleTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    if (this.state.data === void 0) {\n      return true;\n    }\n    if (staleTime === \"static\") {\n      return false;\n    }\n    if (this.state.isInvalidated) {\n      return true;\n    }\n    return !timeUntilStale(this.state.dataUpdatedAt, staleTime);\n  }\n  onFocus() {\n    var _classPrivateFieldGet5;\n    const observer = this.observers.find(x => x.shouldFetchOnWindowFocus());\n    observer === null || observer === void 0 || observer.refetch({\n      cancelRefetch: false\n    });\n    (_classPrivateFieldGet5 = _classPrivateFieldGet(_retryer, this)) === null || _classPrivateFieldGet5 === void 0 || _classPrivateFieldGet5.continue();\n  }\n  onOnline() {\n    var _classPrivateFieldGet6;\n    const observer = this.observers.find(x => x.shouldFetchOnReconnect());\n    observer === null || observer === void 0 || observer.refetch({\n      cancelRefetch: false\n    });\n    (_classPrivateFieldGet6 = _classPrivateFieldGet(_retryer, this)) === null || _classPrivateFieldGet6 === void 0 || _classPrivateFieldGet6.continue();\n  }\n  addObserver(observer) {\n    if (!this.observers.includes(observer)) {\n      this.observers.push(observer);\n      this.clearGcTimeout();\n      _classPrivateFieldGet(_cache, this).notify({\n        type: \"observerAdded\",\n        query: this,\n        observer\n      });\n    }\n  }\n  removeObserver(observer) {\n    if (this.observers.includes(observer)) {\n      this.observers = this.observers.filter(x => x !== observer);\n      if (!this.observers.length) {\n        if (_classPrivateFieldGet(_retryer, this)) {\n          if (_classPrivateFieldGet(_abortSignalConsumed, this)) {\n            _classPrivateFieldGet(_retryer, this).cancel({\n              revert: true\n            });\n          } else {\n            _classPrivateFieldGet(_retryer, this).cancelRetry();\n          }\n        }\n        this.scheduleGc();\n      }\n      _classPrivateFieldGet(_cache, this).notify({\n        type: \"observerRemoved\",\n        query: this,\n        observer\n      });\n    }\n  }\n  getObserversCount() {\n    return this.observers.length;\n  }\n  invalidate() {\n    if (!this.state.isInvalidated) {\n      _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n        type: \"invalidate\"\n      });\n    }\n  }\n  fetch(options, fetchOptions) {\n    var _this$options$behavio, _context$fetchOptions;\n    if (this.state.fetchStatus !== \"idle\") {\n      if (this.state.data !== void 0 && fetchOptions !== null && fetchOptions !== void 0 && fetchOptions.cancelRefetch) {\n        this.cancel({\n          silent: true\n        });\n      } else if (_classPrivateFieldGet(_retryer, this)) {\n        _classPrivateFieldGet(_retryer, this).continueRetry();\n        return _classPrivateFieldGet(_retryer, this).promise;\n      }\n    }\n    if (options) {\n      this.setOptions(options);\n    }\n    if (!this.options.queryFn) {\n      const observer = this.observers.find(x => x.options.queryFn);\n      if (observer) {\n        this.setOptions(observer.options);\n      }\n    }\n    if (process.env.NODE_ENV !== \"production\") {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\"As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']\");\n      }\n    }\n    const abortController = new AbortController();\n    const addSignalProperty = object => {\n      Object.defineProperty(object, \"signal\", {\n        enumerable: true,\n        get: () => {\n          _classPrivateFieldSet(_abortSignalConsumed, this, true);\n          return abortController.signal;\n        }\n      });\n    };\n    const fetchFn = () => {\n      const queryFn = ensureQueryFn(this.options, fetchOptions);\n      const createQueryFnContext = () => {\n        const queryFnContext2 = {\n          client: _classPrivateFieldGet(_client, this),\n          queryKey: this.queryKey,\n          meta: this.meta\n        };\n        addSignalProperty(queryFnContext2);\n        return queryFnContext2;\n      };\n      const queryFnContext = createQueryFnContext();\n      _classPrivateFieldSet(_abortSignalConsumed, this, false);\n      if (this.options.persister) {\n        return this.options.persister(queryFn, queryFnContext, this);\n      }\n      return queryFn(queryFnContext);\n    };\n    const createFetchContext = () => {\n      const context2 = {\n        fetchOptions,\n        options: this.options,\n        queryKey: this.queryKey,\n        client: _classPrivateFieldGet(_client, this),\n        state: this.state,\n        fetchFn\n      };\n      addSignalProperty(context2);\n      return context2;\n    };\n    const context = createFetchContext();\n    (_this$options$behavio = this.options.behavior) === null || _this$options$behavio === void 0 || _this$options$behavio.onFetch(context, this);\n    _classPrivateFieldSet(_revertState, this, this.state);\n    if (this.state.fetchStatus === \"idle\" || this.state.fetchMeta !== ((_context$fetchOptions = context.fetchOptions) === null || _context$fetchOptions === void 0 ? void 0 : _context$fetchOptions.meta)) {\n      var _context$fetchOptions2;\n      _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n        type: \"fetch\",\n        meta: (_context$fetchOptions2 = context.fetchOptions) === null || _context$fetchOptions2 === void 0 ? void 0 : _context$fetchOptions2.meta\n      });\n    }\n    const onError = error => {\n      if (!(isCancelledError(error) && error.silent)) {\n        _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n          type: \"error\",\n          error\n        });\n      }\n      if (!isCancelledError(error)) {\n        var _classPrivateFieldGet7, _classPrivateFieldGet8, _classPrivateFieldGet9, _classPrivateFieldGet0;\n        (_classPrivateFieldGet7 = (_classPrivateFieldGet8 = _classPrivateFieldGet(_cache, this).config).onError) === null || _classPrivateFieldGet7 === void 0 || _classPrivateFieldGet7.call(_classPrivateFieldGet8, error, this);\n        (_classPrivateFieldGet9 = (_classPrivateFieldGet0 = _classPrivateFieldGet(_cache, this).config).onSettled) === null || _classPrivateFieldGet9 === void 0 || _classPrivateFieldGet9.call(_classPrivateFieldGet0, this.state.data, error, this);\n      }\n      this.scheduleGc();\n    };\n    _classPrivateFieldSet(_retryer, this, createRetryer({\n      initialPromise: fetchOptions === null || fetchOptions === void 0 ? void 0 : fetchOptions.initialPromise,\n      fn: context.fetchFn,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: data => {\n        var _classPrivateFieldGet1, _classPrivateFieldGet10, _classPrivateFieldGet11, _classPrivateFieldGet12;\n        if (data === void 0) {\n          if (process.env.NODE_ENV !== \"production\") {\n            console.error(\"Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: \".concat(this.queryHash));\n          }\n          onError(new Error(\"\".concat(this.queryHash, \" data is undefined\")));\n          return;\n        }\n        try {\n          this.setData(data);\n        } catch (error) {\n          onError(error);\n          return;\n        }\n        (_classPrivateFieldGet1 = (_classPrivateFieldGet10 = _classPrivateFieldGet(_cache, this).config).onSuccess) === null || _classPrivateFieldGet1 === void 0 || _classPrivateFieldGet1.call(_classPrivateFieldGet10, data, this);\n        (_classPrivateFieldGet11 = (_classPrivateFieldGet12 = _classPrivateFieldGet(_cache, this).config).onSettled) === null || _classPrivateFieldGet11 === void 0 || _classPrivateFieldGet11.call(_classPrivateFieldGet12, data, this.state.error, this);\n        this.scheduleGc();\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n          type: \"failed\",\n          failureCount,\n          error\n        });\n      },\n      onPause: () => {\n        _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n          type: \"pause\"\n        });\n      },\n      onContinue: () => {\n        _assertClassBrand(_Class_brand, this, _dispatch).call(this, {\n          type: \"continue\"\n        });\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n      canRun: () => true\n    }));\n    return _classPrivateFieldGet(_retryer, this).start();\n  }\n});\nfunction _dispatch(action) {\n  const reducer = state => {\n    var _action$meta, _action$dataUpdatedAt;\n    switch (action.type) {\n      case \"failed\":\n        return _objectSpread(_objectSpread({}, state), {}, {\n          fetchFailureCount: action.failureCount,\n          fetchFailureReason: action.error\n        });\n      case \"pause\":\n        return _objectSpread(_objectSpread({}, state), {}, {\n          fetchStatus: \"paused\"\n        });\n      case \"continue\":\n        return _objectSpread(_objectSpread({}, state), {}, {\n          fetchStatus: \"fetching\"\n        });\n      case \"fetch\":\n        return _objectSpread(_objectSpread(_objectSpread({}, state), fetchState(state.data, this.options)), {}, {\n          fetchMeta: (_action$meta = action.meta) !== null && _action$meta !== void 0 ? _action$meta : null\n        });\n      case \"success\":\n        _classPrivateFieldSet(_revertState, this, void 0);\n        return _objectSpread(_objectSpread({}, state), {}, {\n          data: action.data,\n          dataUpdateCount: state.dataUpdateCount + 1,\n          dataUpdatedAt: (_action$dataUpdatedAt = action.dataUpdatedAt) !== null && _action$dataUpdatedAt !== void 0 ? _action$dataUpdatedAt : Date.now(),\n          error: null,\n          isInvalidated: false,\n          status: \"success\"\n        }, !action.manual && {\n          fetchStatus: \"idle\",\n          fetchFailureCount: 0,\n          fetchFailureReason: null\n        });\n      case \"error\":\n        const error = action.error;\n        if (isCancelledError(error) && error.revert && _classPrivateFieldGet(_revertState, this)) {\n          return _objectSpread(_objectSpread({}, _classPrivateFieldGet(_revertState, this)), {}, {\n            fetchStatus: \"idle\"\n          });\n        }\n        return _objectSpread(_objectSpread({}, state), {}, {\n          error,\n          errorUpdateCount: state.errorUpdateCount + 1,\n          errorUpdatedAt: Date.now(),\n          fetchFailureCount: state.fetchFailureCount + 1,\n          fetchFailureReason: error,\n          fetchStatus: \"idle\",\n          status: \"error\"\n        });\n      case \"invalidate\":\n        return _objectSpread(_objectSpread({}, state), {}, {\n          isInvalidated: true\n        });\n      case \"setState\":\n        return _objectSpread(_objectSpread({}, state), action.state);\n    }\n  };\n  this.state = reducer(this.state);\n  notifyManager.batch(() => {\n    this.observers.forEach(observer => {\n      observer.onQueryUpdate();\n    });\n    _classPrivateFieldGet(_cache, this).notify({\n      query: this,\n      type: \"updated\",\n      action\n    });\n  });\n}\nfunction fetchState(data, options) {\n  return _objectSpread({\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchStatus: canFetch(options.networkMode) ? \"fetching\" : \"paused\"\n  }, data === void 0 && {\n    error: null,\n    status: \"pending\"\n  });\n}\nfunction getDefaultState(options) {\n  const data = typeof options.initialData === \"function\" ? options.initialData() : options.initialData;\n  const hasData = data !== void 0;\n  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === \"function\" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt !== null && initialDataUpdatedAt !== void 0 ? initialDataUpdatedAt : Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? \"success\" : \"pending\",\n    fetchStatus: \"idle\"\n  };\n}\nexport { Query, fetchState };\n//# sourceMappingURL=query.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}