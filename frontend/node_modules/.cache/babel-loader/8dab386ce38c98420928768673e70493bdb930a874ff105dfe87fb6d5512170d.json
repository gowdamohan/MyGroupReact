{"ast":null,"code":"import _objectSpread from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classPrivateFieldInitSpec from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldGet from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nvar _mutations, _scopes, _mutationId;\n// src/mutationCache.ts\nimport { notifyManager } from \"./notifyManager.js\";\nimport { Mutation } from \"./mutation.js\";\nimport { matchMutation, noop } from \"./utils.js\";\nimport { Subscribable } from \"./subscribable.js\";\nvar MutationCache = (_mutations = /*#__PURE__*/new WeakMap(), _scopes = /*#__PURE__*/new WeakMap(), _mutationId = /*#__PURE__*/new WeakMap(), class MutationCache extends Subscribable {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    _classPrivateFieldInitSpec(this, _mutations, void 0);\n    _classPrivateFieldInitSpec(this, _scopes, void 0);\n    _classPrivateFieldInitSpec(this, _mutationId, void 0);\n    this.config = config;\n    _classPrivateFieldSet(_mutations, this, /* @__PURE__ */new Set());\n    _classPrivateFieldSet(_scopes, this, /* @__PURE__ */new Map());\n    _classPrivateFieldSet(_mutationId, this, 0);\n  }\n  build(client, options, state) {\n    var _this$mutationId;\n    const mutation = new Mutation({\n      mutationCache: this,\n      mutationId: _classPrivateFieldSet(_mutationId, this, (_this$mutationId = _classPrivateFieldGet(_mutationId, this), ++_this$mutationId)),\n      options: client.defaultMutationOptions(options),\n      state\n    });\n    this.add(mutation);\n    return mutation;\n  }\n  add(mutation) {\n    _classPrivateFieldGet(_mutations, this).add(mutation);\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const scopedMutations = _classPrivateFieldGet(_scopes, this).get(scope);\n      if (scopedMutations) {\n        scopedMutations.push(mutation);\n      } else {\n        _classPrivateFieldGet(_scopes, this).set(scope, [mutation]);\n      }\n    }\n    this.notify({\n      type: \"added\",\n      mutation\n    });\n  }\n  remove(mutation) {\n    if (_classPrivateFieldGet(_mutations, this).delete(mutation)) {\n      const scope = scopeFor(mutation);\n      if (typeof scope === \"string\") {\n        const scopedMutations = _classPrivateFieldGet(_scopes, this).get(scope);\n        if (scopedMutations) {\n          if (scopedMutations.length > 1) {\n            const index = scopedMutations.indexOf(mutation);\n            if (index !== -1) {\n              scopedMutations.splice(index, 1);\n            }\n          } else if (scopedMutations[0] === mutation) {\n            _classPrivateFieldGet(_scopes, this).delete(scope);\n          }\n        }\n      }\n    }\n    this.notify({\n      type: \"removed\",\n      mutation\n    });\n  }\n  canRun(mutation) {\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      const mutationsWithSameScope = _classPrivateFieldGet(_scopes, this).get(scope);\n      const firstPendingMutation = mutationsWithSameScope === null || mutationsWithSameScope === void 0 ? void 0 : mutationsWithSameScope.find(m => m.state.status === \"pending\");\n      return !firstPendingMutation || firstPendingMutation === mutation;\n    } else {\n      return true;\n    }\n  }\n  runNext(mutation) {\n    const scope = scopeFor(mutation);\n    if (typeof scope === \"string\") {\n      var _classPrivateFieldGet2, _foundMutation$contin;\n      const foundMutation = (_classPrivateFieldGet2 = _classPrivateFieldGet(_scopes, this).get(scope)) === null || _classPrivateFieldGet2 === void 0 ? void 0 : _classPrivateFieldGet2.find(m => m !== mutation && m.state.isPaused);\n      return (_foundMutation$contin = foundMutation === null || foundMutation === void 0 ? void 0 : foundMutation.continue()) !== null && _foundMutation$contin !== void 0 ? _foundMutation$contin : Promise.resolve();\n    } else {\n      return Promise.resolve();\n    }\n  }\n  clear() {\n    notifyManager.batch(() => {\n      _classPrivateFieldGet(_mutations, this).forEach(mutation => {\n        this.notify({\n          type: \"removed\",\n          mutation\n        });\n      });\n      _classPrivateFieldGet(_mutations, this).clear();\n      _classPrivateFieldGet(_scopes, this).clear();\n    });\n  }\n  getAll() {\n    return Array.from(_classPrivateFieldGet(_mutations, this));\n  }\n  find(filters) {\n    const defaultedFilters = _objectSpread({\n      exact: true\n    }, filters);\n    return this.getAll().find(mutation => matchMutation(defaultedFilters, mutation));\n  }\n  findAll() {\n    let filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.getAll().filter(mutation => matchMutation(filters, mutation));\n  }\n  notify(event) {\n    notifyManager.batch(() => {\n      this.listeners.forEach(listener => {\n        listener(event);\n      });\n    });\n  }\n  resumePausedMutations() {\n    const pausedMutations = this.getAll().filter(x => x.state.isPaused);\n    return notifyManager.batch(() => Promise.all(pausedMutations.map(mutation => mutation.continue().catch(noop))));\n  }\n});\nfunction scopeFor(mutation) {\n  var _mutation$options$sco;\n  return (_mutation$options$sco = mutation.options.scope) === null || _mutation$options$sco === void 0 ? void 0 : _mutation$options$sco.id;\n}\nexport { MutationCache };\n//# sourceMappingURL=mutationCache.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}