{"ast":null,"code":"import _objectSpread from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classPrivateFieldInitSpec from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldInitSpec.js\";\nimport _classPrivateFieldGet from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldGet2.js\";\nimport _classPrivateFieldSet from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/classPrivateFieldSet2.js\";\nvar _queryCache, _mutationCache, _defaultOptions, _queryDefaults, _mutationDefaults, _mountCount, _unsubscribeFocus, _unsubscribeOnline;\n// src/queryClient.ts\nimport { functionalUpdate, hashKey, hashQueryKeyByOptions, noop, partialMatchKey, resolveStaleTime, skipToken } from \"./utils.js\";\nimport { QueryCache } from \"./queryCache.js\";\nimport { MutationCache } from \"./mutationCache.js\";\nimport { focusManager } from \"./focusManager.js\";\nimport { onlineManager } from \"./onlineManager.js\";\nimport { notifyManager } from \"./notifyManager.js\";\nimport { infiniteQueryBehavior } from \"./infiniteQueryBehavior.js\";\nvar QueryClient = (_queryCache = /*#__PURE__*/new WeakMap(), _mutationCache = /*#__PURE__*/new WeakMap(), _defaultOptions = /*#__PURE__*/new WeakMap(), _queryDefaults = /*#__PURE__*/new WeakMap(), _mutationDefaults = /*#__PURE__*/new WeakMap(), _mountCount = /*#__PURE__*/new WeakMap(), _unsubscribeFocus = /*#__PURE__*/new WeakMap(), _unsubscribeOnline = /*#__PURE__*/new WeakMap(), class QueryClient {\n  constructor() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    _classPrivateFieldInitSpec(this, _queryCache, void 0);\n    _classPrivateFieldInitSpec(this, _mutationCache, void 0);\n    _classPrivateFieldInitSpec(this, _defaultOptions, void 0);\n    _classPrivateFieldInitSpec(this, _queryDefaults, void 0);\n    _classPrivateFieldInitSpec(this, _mutationDefaults, void 0);\n    _classPrivateFieldInitSpec(this, _mountCount, void 0);\n    _classPrivateFieldInitSpec(this, _unsubscribeFocus, void 0);\n    _classPrivateFieldInitSpec(this, _unsubscribeOnline, void 0);\n    _classPrivateFieldSet(_queryCache, this, config.queryCache || new QueryCache());\n    _classPrivateFieldSet(_mutationCache, this, config.mutationCache || new MutationCache());\n    _classPrivateFieldSet(_defaultOptions, this, config.defaultOptions || {});\n    _classPrivateFieldSet(_queryDefaults, this, /* @__PURE__ */new Map());\n    _classPrivateFieldSet(_mutationDefaults, this, /* @__PURE__ */new Map());\n    _classPrivateFieldSet(_mountCount, this, 0);\n  }\n  mount() {\n    var _this$mountCount, _this$mountCount2;\n    _classPrivateFieldSet(_mountCount, this, (_this$mountCount = _classPrivateFieldGet(_mountCount, this), _this$mountCount2 = _this$mountCount++, _this$mountCount)), _this$mountCount2;\n    if (_classPrivateFieldGet(_mountCount, this) !== 1) return;\n    _classPrivateFieldSet(_unsubscribeFocus, this, focusManager.subscribe(async focused => {\n      if (focused) {\n        await this.resumePausedMutations();\n        _classPrivateFieldGet(_queryCache, this).onFocus();\n      }\n    }));\n    _classPrivateFieldSet(_unsubscribeOnline, this, onlineManager.subscribe(async online => {\n      if (online) {\n        await this.resumePausedMutations();\n        _classPrivateFieldGet(_queryCache, this).onOnline();\n      }\n    }));\n  }\n  unmount() {\n    var _this$mountCount3, _this$mountCount4, _classPrivateFieldGet2, _classPrivateFieldGet3;\n    _classPrivateFieldSet(_mountCount, this, (_this$mountCount3 = _classPrivateFieldGet(_mountCount, this), _this$mountCount4 = _this$mountCount3--, _this$mountCount3)), _this$mountCount4;\n    if (_classPrivateFieldGet(_mountCount, this) !== 0) return;\n    (_classPrivateFieldGet2 = _classPrivateFieldGet(_unsubscribeFocus, this)) === null || _classPrivateFieldGet2 === void 0 || _classPrivateFieldGet2.call(this);\n    _classPrivateFieldSet(_unsubscribeFocus, this, void 0);\n    (_classPrivateFieldGet3 = _classPrivateFieldGet(_unsubscribeOnline, this)) === null || _classPrivateFieldGet3 === void 0 || _classPrivateFieldGet3.call(this);\n    _classPrivateFieldSet(_unsubscribeOnline, this, void 0);\n  }\n  isFetching(filters) {\n    return _classPrivateFieldGet(_queryCache, this).findAll(_objectSpread(_objectSpread({}, filters), {}, {\n      fetchStatus: \"fetching\"\n    })).length;\n  }\n  isMutating(filters) {\n    return _classPrivateFieldGet(_mutationCache, this).findAll(_objectSpread(_objectSpread({}, filters), {}, {\n      status: \"pending\"\n    })).length;\n  }\n  /**\n   * Imperative (non-reactive) way to retrieve data for a QueryKey.\n   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.\n   *\n   * Hint: Do not use this function inside a component, because it won't receive updates.\n   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.\n   */\n  getQueryData(queryKey) {\n    var _classPrivateFieldGet4;\n    const options = this.defaultQueryOptions({\n      queryKey\n    });\n    return (_classPrivateFieldGet4 = _classPrivateFieldGet(_queryCache, this).get(options.queryHash)) === null || _classPrivateFieldGet4 === void 0 ? void 0 : _classPrivateFieldGet4.state.data;\n  }\n  ensureQueryData(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    const query = _classPrivateFieldGet(_queryCache, this).build(this, defaultedOptions);\n    const cachedData = query.state.data;\n    if (cachedData === void 0) {\n      return this.fetchQuery(options);\n    }\n    if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {\n      void this.prefetchQuery(defaultedOptions);\n    }\n    return Promise.resolve(cachedData);\n  }\n  getQueriesData(filters) {\n    return _classPrivateFieldGet(_queryCache, this).findAll(filters).map(_ref => {\n      let {\n        queryKey,\n        state\n      } = _ref;\n      const data = state.data;\n      return [queryKey, data];\n    });\n  }\n  setQueryData(queryKey, updater, options) {\n    const defaultedOptions = this.defaultQueryOptions({\n      queryKey\n    });\n    const query = _classPrivateFieldGet(_queryCache, this).get(defaultedOptions.queryHash);\n    const prevData = query === null || query === void 0 ? void 0 : query.state.data;\n    const data = functionalUpdate(updater, prevData);\n    if (data === void 0) {\n      return void 0;\n    }\n    return _classPrivateFieldGet(_queryCache, this).build(this, defaultedOptions).setData(data, _objectSpread(_objectSpread({}, options), {}, {\n      manual: true\n    }));\n  }\n  setQueriesData(filters, updater, options) {\n    return notifyManager.batch(() => _classPrivateFieldGet(_queryCache, this).findAll(filters).map(_ref2 => {\n      let {\n        queryKey\n      } = _ref2;\n      return [queryKey, this.setQueryData(queryKey, updater, options)];\n    }));\n  }\n  getQueryState(queryKey) {\n    var _classPrivateFieldGet5;\n    const options = this.defaultQueryOptions({\n      queryKey\n    });\n    return (_classPrivateFieldGet5 = _classPrivateFieldGet(_queryCache, this).get(options.queryHash)) === null || _classPrivateFieldGet5 === void 0 ? void 0 : _classPrivateFieldGet5.state;\n  }\n  removeQueries(filters) {\n    const queryCache = _classPrivateFieldGet(_queryCache, this);\n    notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        queryCache.remove(query);\n      });\n    });\n  }\n  resetQueries(filters, options) {\n    const queryCache = _classPrivateFieldGet(_queryCache, this);\n    return notifyManager.batch(() => {\n      queryCache.findAll(filters).forEach(query => {\n        query.reset();\n      });\n      return this.refetchQueries(_objectSpread({\n        type: \"active\"\n      }, filters), options);\n    });\n  }\n  cancelQueries(filters) {\n    let cancelOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const defaultedCancelOptions = _objectSpread({\n      revert: true\n    }, cancelOptions);\n    const promises = notifyManager.batch(() => _classPrivateFieldGet(_queryCache, this).findAll(filters).map(query => query.cancel(defaultedCancelOptions)));\n    return Promise.all(promises).then(noop).catch(noop);\n  }\n  invalidateQueries(filters) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return notifyManager.batch(() => {\n      var _ref3, _filters$refetchType;\n      _classPrivateFieldGet(_queryCache, this).findAll(filters).forEach(query => {\n        query.invalidate();\n      });\n      if ((filters === null || filters === void 0 ? void 0 : filters.refetchType) === \"none\") {\n        return Promise.resolve();\n      }\n      return this.refetchQueries(_objectSpread(_objectSpread({}, filters), {}, {\n        type: (_ref3 = (_filters$refetchType = filters === null || filters === void 0 ? void 0 : filters.refetchType) !== null && _filters$refetchType !== void 0 ? _filters$refetchType : filters === null || filters === void 0 ? void 0 : filters.type) !== null && _ref3 !== void 0 ? _ref3 : \"active\"\n      }), options);\n    });\n  }\n  refetchQueries(filters) {\n    var _options$cancelRefetc;\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const fetchOptions = _objectSpread(_objectSpread({}, options), {}, {\n      cancelRefetch: (_options$cancelRefetc = options.cancelRefetch) !== null && _options$cancelRefetc !== void 0 ? _options$cancelRefetc : true\n    });\n    const promises = notifyManager.batch(() => _classPrivateFieldGet(_queryCache, this).findAll(filters).filter(query => !query.isDisabled() && !query.isStatic()).map(query => {\n      let promise = query.fetch(void 0, fetchOptions);\n      if (!fetchOptions.throwOnError) {\n        promise = promise.catch(noop);\n      }\n      return query.state.fetchStatus === \"paused\" ? Promise.resolve() : promise;\n    }));\n    return Promise.all(promises).then(noop);\n  }\n  fetchQuery(options) {\n    const defaultedOptions = this.defaultQueryOptions(options);\n    if (defaultedOptions.retry === void 0) {\n      defaultedOptions.retry = false;\n    }\n    const query = _classPrivateFieldGet(_queryCache, this).build(this, defaultedOptions);\n    return query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query)) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);\n  }\n  prefetchQuery(options) {\n    return this.fetchQuery(options).then(noop).catch(noop);\n  }\n  fetchInfiniteQuery(options) {\n    options.behavior = infiniteQueryBehavior(options.pages);\n    return this.fetchQuery(options);\n  }\n  prefetchInfiniteQuery(options) {\n    return this.fetchInfiniteQuery(options).then(noop).catch(noop);\n  }\n  ensureInfiniteQueryData(options) {\n    options.behavior = infiniteQueryBehavior(options.pages);\n    return this.ensureQueryData(options);\n  }\n  resumePausedMutations() {\n    if (onlineManager.isOnline()) {\n      return _classPrivateFieldGet(_mutationCache, this).resumePausedMutations();\n    }\n    return Promise.resolve();\n  }\n  getQueryCache() {\n    return _classPrivateFieldGet(_queryCache, this);\n  }\n  getMutationCache() {\n    return _classPrivateFieldGet(_mutationCache, this);\n  }\n  getDefaultOptions() {\n    return _classPrivateFieldGet(_defaultOptions, this);\n  }\n  setDefaultOptions(options) {\n    _classPrivateFieldSet(_defaultOptions, this, options);\n  }\n  setQueryDefaults(queryKey, options) {\n    _classPrivateFieldGet(_queryDefaults, this).set(hashKey(queryKey), {\n      queryKey,\n      defaultOptions: options\n    });\n  }\n  getQueryDefaults(queryKey) {\n    const defaults = [..._classPrivateFieldGet(_queryDefaults, this).values()];\n    const result = {};\n    defaults.forEach(queryDefault => {\n      if (partialMatchKey(queryKey, queryDefault.queryKey)) {\n        Object.assign(result, queryDefault.defaultOptions);\n      }\n    });\n    return result;\n  }\n  setMutationDefaults(mutationKey, options) {\n    _classPrivateFieldGet(_mutationDefaults, this).set(hashKey(mutationKey), {\n      mutationKey,\n      defaultOptions: options\n    });\n  }\n  getMutationDefaults(mutationKey) {\n    const defaults = [..._classPrivateFieldGet(_mutationDefaults, this).values()];\n    const result = {};\n    defaults.forEach(queryDefault => {\n      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {\n        Object.assign(result, queryDefault.defaultOptions);\n      }\n    });\n    return result;\n  }\n  defaultQueryOptions(options) {\n    if (options._defaulted) {\n      return options;\n    }\n    const defaultedOptions = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, _classPrivateFieldGet(_defaultOptions, this).queries), this.getQueryDefaults(options.queryKey)), options), {}, {\n      _defaulted: true\n    });\n    if (!defaultedOptions.queryHash) {\n      defaultedOptions.queryHash = hashQueryKeyByOptions(defaultedOptions.queryKey, defaultedOptions);\n    }\n    if (defaultedOptions.refetchOnReconnect === void 0) {\n      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== \"always\";\n    }\n    if (defaultedOptions.throwOnError === void 0) {\n      defaultedOptions.throwOnError = !!defaultedOptions.suspense;\n    }\n    if (!defaultedOptions.networkMode && defaultedOptions.persister) {\n      defaultedOptions.networkMode = \"offlineFirst\";\n    }\n    if (defaultedOptions.queryFn === skipToken) {\n      defaultedOptions.enabled = false;\n    }\n    return defaultedOptions;\n  }\n  defaultMutationOptions(options) {\n    if (options !== null && options !== void 0 && options._defaulted) {\n      return options;\n    }\n    return _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, _classPrivateFieldGet(_defaultOptions, this).mutations), (options === null || options === void 0 ? void 0 : options.mutationKey) && this.getMutationDefaults(options.mutationKey)), options), {}, {\n      _defaulted: true\n    });\n  }\n  clear() {\n    _classPrivateFieldGet(_queryCache, this).clear();\n    _classPrivateFieldGet(_mutationCache, this).clear();\n  }\n});\nexport { QueryClient };\n//# sourceMappingURL=queryClient.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}