{"ast":null,"code":"// src/retryer.ts\nimport { focusManager } from \"./focusManager.js\";\nimport { onlineManager } from \"./onlineManager.js\";\nimport { pendingThenable } from \"./thenable.js\";\nimport { isServer, sleep } from \"./utils.js\";\nfunction defaultRetryDelay(failureCount) {\n  return Math.min(1e3 * 2 ** failureCount, 3e4);\n}\nfunction canFetch(networkMode) {\n  return (networkMode !== null && networkMode !== void 0 ? networkMode : \"online\") === \"online\" ? onlineManager.isOnline() : true;\n}\nvar CancelledError = class extends Error {\n  constructor(options) {\n    super(\"CancelledError\");\n    this.revert = options === null || options === void 0 ? void 0 : options.revert;\n    this.silent = options === null || options === void 0 ? void 0 : options.silent;\n  }\n};\nfunction isCancelledError(value) {\n  return value instanceof CancelledError;\n}\nfunction createRetryer(config) {\n  let isRetryCancelled = false;\n  let failureCount = 0;\n  let isResolved = false;\n  let continueFn;\n  const thenable = pendingThenable();\n  const cancel = cancelOptions => {\n    if (!isResolved) {\n      var _config$abort;\n      reject(new CancelledError(cancelOptions));\n      (_config$abort = config.abort) === null || _config$abort === void 0 || _config$abort.call(config);\n    }\n  };\n  const cancelRetry = () => {\n    isRetryCancelled = true;\n  };\n  const continueRetry = () => {\n    isRetryCancelled = false;\n  };\n  const canContinue = () => focusManager.isFocused() && (config.networkMode === \"always\" || onlineManager.isOnline()) && config.canRun();\n  const canStart = () => canFetch(config.networkMode) && config.canRun();\n  const resolve = value => {\n    if (!isResolved) {\n      var _config$onSuccess, _continueFn;\n      isResolved = true;\n      (_config$onSuccess = config.onSuccess) === null || _config$onSuccess === void 0 || _config$onSuccess.call(config, value);\n      (_continueFn = continueFn) === null || _continueFn === void 0 || _continueFn();\n      thenable.resolve(value);\n    }\n  };\n  const reject = value => {\n    if (!isResolved) {\n      var _config$onError, _continueFn2;\n      isResolved = true;\n      (_config$onError = config.onError) === null || _config$onError === void 0 || _config$onError.call(config, value);\n      (_continueFn2 = continueFn) === null || _continueFn2 === void 0 || _continueFn2();\n      thenable.reject(value);\n    }\n  };\n  const pause = () => {\n    return new Promise(continueResolve => {\n      var _config$onPause;\n      continueFn = value => {\n        if (isResolved || canContinue()) {\n          continueResolve(value);\n        }\n      };\n      (_config$onPause = config.onPause) === null || _config$onPause === void 0 || _config$onPause.call(config);\n    }).then(() => {\n      continueFn = void 0;\n      if (!isResolved) {\n        var _config$onContinue;\n        (_config$onContinue = config.onContinue) === null || _config$onContinue === void 0 || _config$onContinue.call(config);\n      }\n    });\n  };\n  const run = () => {\n    if (isResolved) {\n      return;\n    }\n    let promiseOrValue;\n    const initialPromise = failureCount === 0 ? config.initialPromise : void 0;\n    try {\n      promiseOrValue = initialPromise !== null && initialPromise !== void 0 ? initialPromise : config.fn();\n    } catch (error) {\n      promiseOrValue = Promise.reject(error);\n    }\n    Promise.resolve(promiseOrValue).then(resolve).catch(error => {\n      var _config$retry, _config$retryDelay, _config$onFail;\n      if (isResolved) {\n        return;\n      }\n      const retry = (_config$retry = config.retry) !== null && _config$retry !== void 0 ? _config$retry : isServer ? 0 : 3;\n      const retryDelay = (_config$retryDelay = config.retryDelay) !== null && _config$retryDelay !== void 0 ? _config$retryDelay : defaultRetryDelay;\n      const delay = typeof retryDelay === \"function\" ? retryDelay(failureCount, error) : retryDelay;\n      const shouldRetry = retry === true || typeof retry === \"number\" && failureCount < retry || typeof retry === \"function\" && retry(failureCount, error);\n      if (isRetryCancelled || !shouldRetry) {\n        reject(error);\n        return;\n      }\n      failureCount++;\n      (_config$onFail = config.onFail) === null || _config$onFail === void 0 || _config$onFail.call(config, failureCount, error);\n      sleep(delay).then(() => {\n        return canContinue() ? void 0 : pause();\n      }).then(() => {\n        if (isRetryCancelled) {\n          reject(error);\n        } else {\n          run();\n        }\n      });\n    });\n  };\n  return {\n    promise: thenable,\n    cancel,\n    continue: () => {\n      var _continueFn3;\n      (_continueFn3 = continueFn) === null || _continueFn3 === void 0 || _continueFn3();\n      return thenable;\n    },\n    cancelRetry,\n    continueRetry,\n    canStart,\n    start: () => {\n      if (canStart()) {\n        run();\n      } else {\n        pause().then(run);\n      }\n      return thenable;\n    }\n  };\n}\nexport { CancelledError, canFetch, createRetryer, isCancelledError };\n//# sourceMappingURL=retryer.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}