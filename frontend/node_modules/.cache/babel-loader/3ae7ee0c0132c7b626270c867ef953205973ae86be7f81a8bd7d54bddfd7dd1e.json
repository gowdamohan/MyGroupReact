{"ast":null,"code":"import _asyncIterator from \"D:/MyGroupReact/frontend/node_modules/@babel/runtime/helpers/esm/asyncIterator.js\";\n// src/streamedQuery.ts\nimport { addToEnd } from \"./utils.js\";\nfunction streamedQuery(_ref) {\n  let {\n    queryFn,\n    refetchMode = \"reset\",\n    maxChunks\n  } = _ref;\n  return async context => {\n    const query = context.client.getQueryCache().find({\n      queryKey: context.queryKey,\n      exact: true\n    });\n    const isRefetch = !!query && query.state.data !== void 0;\n    if (isRefetch && refetchMode === \"reset\") {\n      query.setState({\n        status: \"pending\",\n        data: void 0,\n        error: null,\n        fetchStatus: \"fetching\"\n      });\n    }\n    let result = [];\n    const stream = await queryFn(context);\n    var _iteratorAbruptCompletion = false;\n    var _didIteratorError = false;\n    var _iteratorError;\n    try {\n      for (var _iterator = _asyncIterator(stream), _step; _iteratorAbruptCompletion = !(_step = await _iterator.next()).done; _iteratorAbruptCompletion = false) {\n        const chunk = _step.value;\n        {\n          if (context.signal.aborted) {\n            break;\n          }\n          if (!isRefetch || refetchMode !== \"replace\") {\n            context.client.setQueryData(context.queryKey, function () {\n              let prev = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n              return addToEnd(prev, chunk, maxChunks);\n            });\n          }\n          result = addToEnd(result, chunk, maxChunks);\n        }\n      }\n    } catch (err) {\n      _didIteratorError = true;\n      _iteratorError = err;\n    } finally {\n      try {\n        if (_iteratorAbruptCompletion && _iterator.return != null) {\n          await _iterator.return();\n        }\n      } finally {\n        if (_didIteratorError) {\n          throw _iteratorError;\n        }\n      }\n    }\n    if (isRefetch && refetchMode === \"replace\" && !context.signal.aborted) {\n      context.client.setQueryData(context.queryKey, result);\n    }\n    return context.client.getQueryData(context.queryKey);\n  };\n}\nexport { streamedQuery };\n//# sourceMappingURL=streamedQuery.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}